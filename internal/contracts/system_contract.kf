database truflation_system_contract;

// `system_streams` is the table that stores the streams that have been accepted by the TSN Gov
table system_streams {
    stream_id text notnull minlen(32) maxlen(32), // stream id, name of contract in form of a hash, starts with st
    data_provider text notnull minlen(40) maxlen(40), // wallet address, deployer of contract, does NOT start with 0x
    accepted_at int notnull, // blockheight
    revoked_at int, // blockheight

    #data_provider_stream_id_idx primary(data_provider, stream_id)
}

procedure get_official_stream($data_provider text, $stream_id text) private view returns (result bool) {
    for $row in SELECT * FROM system_streams WHERE data_provider = $data_provider AND stream_id = $stream_id AND revoked_at IS NULL {
        return $row.stream_id != null;
    }

    return false;
}

// Verify hex enforces the format `ab1234` instead of `0xab1234` so we can quickly spot errors
// it may be removed as soon as we can normalize hex inputs, but for now we can't because substring is not supported
procedure verify_hex($text text) private {
    $hex text := decode($text, 'hex');
}

foreign procedure get_metadata($key text, $only_latest bool) returns table(
    row_id uuid,
    value_i int,
    value_f decimal(10, 3),
    value_b bool,
    value_s text,
    value_ref text,
    created_at int
)

procedure stream_exists($data_provider text, $stream_id text) public view returns (result bool) {
    $dbid text := generate_dbid($data_provider, $stream_id);

    for $row in SELECT * FROM get_metadata[$dbid, 'get_metadata']('type', true) {
        return true;
    }

    return false;
}

procedure accept_stream($data_provider text, $stream_id text) public owner {
    // TODO: check if stream exists
    $stream_exists bool := stream_exists($data_provider, $stream_id);
    if $stream_exists == false {
        error('stream does not exist');
    }

    // TODO: if it's a composed stream, check if all children are already system streams

    $is_official_stream bool := get_official_stream($data_provider, $stream_id);

    if $is_official_stream == true {
        error('this stream is already official');
    }

    $current_blockheight int := @height;

    verify_hex($data_provider);

    INSERT INTO system_streams (stream_id, data_provider, accepted_at)
    VALUES ($stream_id, $data_provider, $current_blockheight);
}

procedure revoke_stream($data_provider text, $stream_id text) public owner {
    $is_official_stream bool := get_official_stream($data_provider, $stream_id);

    // Check if
    if $is_official_stream == false {
        error('this stream is not official');
    }

    $current_blockheight int := @height;

    UPDATE system_streams SET revoked_at = $current_blockheight WHERE data_provider = $data_provider AND stream_id = $stream_id;
}

foreign procedure ext_get_record($date_from text, $date_to text, $frozen_at text) returns table(
    date_value text,
    value int
)

foreign procedure ext_get_index($date_from text, $date_to text, $frozen_at text) returns table(
    date_value text,
    value int
)

procedure get_unsafe_record($data_provider text, $stream_id text, $date_from text, $date_to text, $frozen_at text) public view returns table(
    date_value text,
    value int
) {
    $dbid text := generate_dbid($data_provider, $stream_id);

    for $row in SELECT * FROM ext_get_record[$dbid, 'get_record']($date_from, $date_to, $frozen_at) {
        return next $row.date_value, $row.value;
    }
}

procedure generate_dbid($data_provider text, $stream_id text) private view returns (result text) {
    $starts_with_0x bool := false;
    for $row in SELECT $data_provider LIKE '0x%' as a {
        $starts_with_0x := $row.a;
    }

    $data_provider_without_0x text;

    if $starts_with_0x == true {
        // TODO: once substring, left or right function is supported, we can remove this
        // for $row in SELECT substr($data_provider, 2) as a {
        //     $data_provider_without_0x := $row.a;
        // }
        error('data provider should not start with 0x');
    } else {
        $data_provider_without_0x := $data_provider;
    }

    $encoded_stream_id := encode(lower($stream_id)::blob, 'hex');

    for $row2 in SELECT
    'x' || encode(
        digest(
                decode($encoded_stream_id || $data_provider_without_0x, 'hex'),
                'sha224'
        ),
        'hex'
       ) AS dbid {
           return $row2.dbid;
       }

    error('could not generate dbid');
}

procedure get_unsafe_index($data_provider text, $stream_id text, $date_from text, $date_to text, $frozen_at text) public view returns table(
    date_value text,
    value int
) {
    $dbid text := generate_dbid($data_provider, $stream_id);

    for $row in SELECT * FROM ext_get_index[$dbid, 'get_index']($date_from, $date_to, $frozen_at) {
        return next $row.date_value, $row.value;
    }
}

procedure get_record($data_provider text, $stream_id text, $date_from text, $date_to text, $frozen_at text) public view returns table(
    date_value text,
    value int
) {

    $is_official_stream bool := get_official_stream($data_provider, $stream_id);

    if $is_official_stream == false {
        error('this stream is not official');
    }

    $dbid text := generate_dbid($data_provider, $stream_id);

    for $row in SELECT * FROM get_unsafe_record($data_provider, $stream_id, $date_from, $date_to, $frozen_at) {
        return next $row.date_value, $row.value;
    }

}

procedure get_index($data_provider text, $stream_id text, $date_from text, $date_to text, $frozen_at text) public view returns table(
    date_value text,
    value int
) {
    $is_official_stream bool := get_official_stream($data_provider, $stream_id);

    if $is_official_stream == false {
        error('this stream is not official');
    }

    $dbid text := generate_dbid($data_provider, $stream_id);

    for $row in SELECT * FROM ext_get_index[$dbid, 'get_index']($date_from, $date_to, $frozen_at) {
        return next $row.date_value, $row.value;
    }
}